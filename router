#!/usr/bin/env python3

# CLI-arg parsing
import argparse

# R/W socket data
import json

# Enumerate structure
from enum import Enum

# Sockets
from socket import socket, SOCK_SEQPACKET, AF_UNIX

# Async
import selectors

verbose = False


def log(msg):
    """Logs the provided message, if logging is enabled."""
    if verbose:
        print(msg)


### Necessary Enum structures
### -------------------------


class Relationship(Enum):
    """The relationship between two BGP neighbors"""

    CUST = "cust"
    PROV = "prov"
    PEER = "peer"

    @classmethod
    def from_str(cls, string):
        """Converts the provided relationship string into its enum class form.

        string str: The string indicating some relationship between BGP nodes

        returns: The relationship object corresponding to the input argument
        """
        for rel in cls:
            if rel.value == string:
                return rel
        raise ValueError(f"Could not locate relationship type of neighbor: {string}")


class Origin(Enum):
    """A router location, internal or external of the local AS"""

    IGP = "IGP"
    EGP = "EGP"
    UNK = "UNK"

    @classmethod
    def from_str(cls, string):
        """Converts the provided origin string into its enum class form.

        string str: The string indicating the origin of some BGP node

        returns: The origin object corresponding to the input argument
        """
        for orig in cls:
            if orig.value == string:
                return orig
        return cls.UNK


class MessageType(Enum):
    """The various different forms a message may take"""

    update = "update"
    revoke = "revoke"
    data = "data"
    no_route = "no route"
    dump = "dump"
    table = "table"

    @classmethod
    def from_str(cls, string):
        """Converts the provided message type string into its enum class form.

        string str: The string indicating a message type

        returns: The message type object corresponding to the input argument
        """
        for category in cls:
            if category.value == string:
                return category
        return None


### Core Structures
### ---------------


class IpAddress:
    def __init__(self, string):
        """Creates an IpAddress object from a quad-dotted notation string

        string str: The input string, a quad-dotted notation ip address
        """
        ip_bytes = list(map(int, string.split(".")))
        assert (
            len(ip_bytes) == 4
        ), "Invalid IpAddress, only accepts quad-dotted notation"
        self._addr = self._bytes_to_int(ip_bytes)

    def _bytes_to_int(self, ip_bytes):
        """Converts a tuple of bytes into a single integer

        ip_bytes (int): A tuple consisting of four elements: the bytes representing an ip address

        returns: A single integer, equivalent to the input bytes
        """
        b1, b2, b3, b4 = map(lambda x: x & 0xFF, ip_bytes)
        return b1 << 24 | b2 << 16 | b3 << 8 | b4

    def _int_to_bytes(self, ip_int):
        """Converts an integer into a tuple of bytes

        ip_int int: The integer representing an ip address

        returns: A list of four bytes; each byte in the ip address
        """
        ip_bytes = []
        for i in range(4):
            shift = 0xFF << (i * 8)
            ip_byte = (ip_int & shift) >> (i * 8)
            ip_bytes.append(ip_byte)
        return ip_bytes[::-1]

    def to_bytes(self):
        """Converts this ip address to a list of bytes"""
        return self._int_to_bytes(self._addr)

    def to_str(self):
        """Converts this ip address to a dotted-decimal string"""
        return ".".join(map(str, self.to_bytes()))


class Serializer:
    """An encapsulation of the ability to serialize an object to a dictionary."""

    def to_dict(self):
        """Converts this object to a dictionary representation."""
        return {}


class NetworkDesc(Serializer):
    """Encapsulates the traits describing a network."""

    def __init__(self, localpref, selfOrigin, asPath, origin):
        """Constructs a network description object from the provided information.

        localpref str: The weight assigned to this network (higher is better)
        selfOrigin str: Whether this route was added by the local administrator or not
        asPath list(str): The list of autonomous systems traversed along this path (shorter is better)
        origin str: Location of the source of this route, within the local AS, external, or unknown
        """
        self.localpref = int(localpref)
        self.selfOrigin = bool(selfOrigin)
        self.asPath = list(asPath)
        self.origin = Origin.from_str(origin)

    def equal(self, other):
        """Checks whether this network description is identical (or equal) to the other network.

        other NetworkDesc: The other network description, to compare this one to

        returns: True if the provided network description is identical to this one, False otherwise
        """
        return all(
            self.localpref == other.localpref,
            self.selfOrigin == other.selfOrigin,
            self.asPath == other.asPath,
            self.origin == other.origin,
        )

    def to_dict(self):
        return {
            "localpref": self.localpref,
            "selfOrigin": self.selfOrigin,
            "ASPath": self.asPath,
            "origin": self.origin.value,
        }


class Network(Serializer):
    """Encapsulates a network, with information about the route leading to this destination."""

    def __init__(self, net_prefix, net_mask, net_desc):
        """Constructs a network object with the provided information

        net_prefix IpAddress: The prefix describing this network
        net_mask IpAddress: The subnet mask describing this network
        net_desc NetworkDesc: The traits associated with this network
        """
        self.prefix = net_prefix
        self.mask = net_mask
        self.desc = net_desc

    def leads_to(self, target):
        """Determines whether or not this network contains the provided ip address.

        target IpAddress: The address to check this network for

        returns: True if the address is located within this network, False otherwise
        """
        # log(f"Checking whether {target.to_str()} is in {self.prefix.to_str()}/{self.mask.to_str()}")
        return (target._addr & self.mask._addr) == (self.prefix._addr & self.mask._addr)

    def to_dict(self):
        if self.desc:
            dct = self.desc.to_dict()
        else:
            dct = {}
        dct["network"] = self.prefix.to_str()
        dct["netmask"] = self.mask.to_str()
        return dct


### Argument Parsing
### ----------------


class ArgumentParser:
    """An object to handle CLI arguments."""

    def __init__(self):
        """Creates a new internal parser object."""
        self.parser = self._create_parser()

    def _create_parser(self):
        """Sets up a new parser object and returns it."""

        def parse_neighbor(string):
            """A utility function to parse the neighbor input into an ip address and relationship identifier

            string str: A string of the form [ip address]-[relationship]

            returns: (The ip address), (The relationship); a tuple describing the neighbor
            """
            addr, rel = string.split("-")
            return IpAddress(addr), Relationship.from_str(rel)

        parser = argparse.ArgumentParser(
            description="A BGP router implementation in python."
        )
        parser.add_argument(
            "asn",
            type=int,
            help="The AS (autonomous system) number, which is uniquely assigned to identify this router",
        )
        parser.add_argument(
            "neighbor",
            nargs="+",
            type=parse_neighbor,
            help="The IP address and relationship of a neighboring router",
            metavar="<IP_Address>-<peer|prov|cust>",
        )
        return parser

    def parse(self):
        """Parses the arguments into information

        returns: (int, (IpAddress, Relationship)); a tuple consisting of:
                the autonomous system number uniquely identifying this node
                a list of addresses and their relationship to this node, representing all neighbors
        """
        args = self.parser.parse_args()
        return args.asn, args.neighbor


### Networking Core
### ---------------

# Number of bytes to read on each call to `recv` of a socket
BUFF_SIZE = 4096


class Neighbor:
    """Encapsulates the link between this node and some neighbor."""

    def __init__(self, addr, relation):
        """Constructs a new neighbor object, describing a neighboring BGP node

        addr IpAddress: The ip address of the neighboring node
        relation Relationship: The relationship between this neighbor and this node
        """
        addr = addr.to_str()
        self.relation = relation
        # The address of the neighboring router
        self.peer_addr = IpAddress(addr)
        # The address our router is using to communicate with this neighbor
        self.addr = IpAddress(addr[:-1] + "1")

        log(f"Created neighbor object ({relation.value}) @ {addr}.")

        # The socket communicating with this neighbor
        self.sock = socket(AF_UNIX, SOCK_SEQPACKET)
        self.sock.setblocking(False)
        self.sock.connect(addr)

        log(f"Neighbor {addr} successfully connected.")

    def recv_msg(self):
        """Receives a message from this neighbor.

        Will attempt to read from the buffer and then convert this data into a
        json continuously. The assumption is that the network will deliver the
        packets correctly, and we must continue attempting to receive the entire
        object before accepting the message.
        """
        m = b""
        while True:
            # Read socket
            m += self.sock.recv(BUFF_SIZE)
            try:
                # Attempt to deserialize
                result = json.loads(m)
            except json.JSONDecodeError:
                # Could not interpret json object, must not be done receiving it
                pass
            else:
                # Successfully loaded object
                return result

    def send_msg(self, msg):
        """Sends the provided message.

        msg Message: The message object to serialize, then send to this neighbor
        """
        log(
            f"Neighbor {self.addr.to_str()} sending message of type {msg.msg_type.value}"
        )
        self.sock.sendall(json.dumps(msg.to_dict()).encode("ascii"))

    def close(self):
        """Closes the socket, terminating the connection to this neighbor."""
        self.sock.close()


class Router:
    """Encapsulates a BGP router node, with a provided asn and neighboring routers."""

    def __init__(self, asn, neighbors):
        """Creates a new router object, to handle neighboring nodes and messages

        asn int: The unique identifier associated with this node
        neighbors [Neighbor]: A list of neighboring bgp router objects
        """
        self.asn = asn
        log(f"Created router object with id {asn}.")
        self.selector = selectors.EpollSelector()
        for n in neighbors:
            self._register_neighbor(n)
        self.forwarding_lookup = ForwardingLookup(neighbors)

    def _register_neighbor(self, neighbor):
        """Registers this neighbor with the selector object

        neighbor Neighbor: The neighbor to register, indicating messages may be received from them
        """
        self.selector.register(neighbor.sock, selectors.EVENT_READ, neighbor)
        log(f"Registered neighbor {neighbor.addr.to_str()} on polling object.")

    def run(self):
        """Continuously loops, checking for new messages from neighbors and reacting to them."""
        log(f"Running...")
        while True:
            for key, _ in self.selector.select():
                sender = key.data
                msg = parse_msg(sender.recv_msg())
                self._accept(sender, msg)

    def notify_peers(self, sender, msg):
        """Notifies the necessary peers of the network change

        sender Neighbor: The neighbor which is the source of the notification
        msg Message: The message sent
        """

        def msg_factory(msg):
            """A helper function to produce the desired message object factory."""
            if msg.msg_type is MessageType.update:
                return lambda n: UpdateMsg(n.addr, n.peer_addr, msg.network)
            else:
                return lambda n: RevokeMsg(n.addr, n.peer_addr, msg.networks)

        # Helper function to check if the neighbor is a customer
        check_cust = lambda neighbor: neighbor.relation is Relationship.CUST
        neighbors = self.forwarding_lookup.tables.keys()
        factory = msg_factory(msg)

        if check_cust(sender):
            # Notify all other neighbors (except sender)
            for neighbor in neighbors:
                if neighbor is not sender:
                    # Notify neighbor
                    neighbor.send_msg(factory(neighbor))
        else:
            # Notify all customers
            custs = filter(check_cust, neighbors)
            for neighbor in custs:
                # Notify neighbor
                neighbor.send_msg(factory(neighbor))

    def _accept(self, sender, msg):
        """Accepts a message that has been received, to be processed

        sender Neighbor: The neighbor object from which this message came
        msg Message: The message object received
        """
        t = msg.msg_type
        if t is MessageType.update:
            # Received an update message
            # Add our asn to the as path
            msg.network.desc.asPath.append(self.asn)
            # Insert network into forwarding table
            self.forwarding_lookup.update(sender, msg.network)
            # Notify peers
            self.notify_peers(sender, msg)
        elif t is MessageType.revoke:
            # Received a revoke message
            # Remove any overlapping networks from forwarding table
            for net in msg.networks:
                self.forwarding_lookup.revoke(sender, net)
            # Notify peers
            self.notify_peers(sender, msg)
        elif t is MessageType.data:
            # Received a data message
            # Find all possible routes
            # Determine best route
            # TODO Ensure data is being forwarded legally
            next_hop = self.forwarding_lookup.best_route(msg.dst)
            if next_hop:
                # Deliver packet
                next_hop.send_msg(msg)
            else:
                # OR return no route message to sender
                sender.send_msg(NoRouteMsg(sender.addr, msg.src))
        elif t is MessageType.dump:
            # Received a dump message
            # Create table message encapsulating current state
            # Return to sender
            sender.send_msg(
                TableMsg(msg.dst, msg.src, self.forwarding_lookup.to_dict())
            )


### Networking Logic
### ----------------


class ForwardingLookup(Serializer):
    """Encapsulates a lookup table for a router, mapping each neighbor to its available networks."""

    def __init__(self, neighbors):
        """Creates a new lookup table, mapping each provided neighbor to an empty forwarding table.

        neighbors [Neighbor]: A list of next-hop routers
        """
        self.tables = {neighbor: ForwardingTable() for neighbor in neighbors}

    def update(self, target, network):
        """Updates the target neighbors forwarding table with the new network.

        target Neighbor: The neighboring router whose forwarding table to update
        network Network: The new network that is available through the target
        """
        self.tables[target].update(network)

    def revoke(self, target, network):
        """Updates the target neighbors forwarding table by removing the new network.

        target Neighbor: The neighboring router whose forwarding table to update
        network Network: The network to remove from this targets forwarding table
        """
        self.tables[target].revoke(network)

    def best_route(self, target):
        """Locates the best neighbor to forward a packet to, in order to reach
        the provided destination. If no neighboring routers may forward the packet
        to its destination, the `None` is returned.

        target IpAddress: The target for which to find a route to

        returns: The neighbor object with the optimal route to the target, or `None` if
        no appropriate route could be found.
        """
        routes = []
        for neighbor, table in self.tables.items():
            route = table.best_route(target)
            if route:
                # Collect all non-null possible routes
                routes.append((neighbor, route))
        if len(routes) == 0:
            # Base case
            return None
        elif len(routes) == 1:
            return routes.pop()[0]
        else:
            # Largest netmask
            max_mask = max(map(lambda r: r[1].mask._addr, routes))
            routes = list(filter(lambda r: r[1].mask._addr == max_mask, routes))
            if len(routes) == 1:
                return routes.pop()[0]
            else:
                # Highest localpref
                max_pref = max(map(lambda r: r[1].desc.localpref, routes))
                routes = list(filter(lambda r: r[1].desc.localpref == max_pref, routes))
                if len(routes) == 1:
                    return routes.pop()[0]
                else:
                    # selfOrigin = True
                    if any(map(lambda r: r[1].desc.selfOrigin, routes)):
                        routes = list(filter(lambda r: r[1].desc.selfOrigin, routes))
                    if len(routes) == 1:
                        return routes.pop()[0]
                    else:
                        # Shortest AS Path
                        min_path = min(map(lambda r: len(r[1].desc.asPath), routes))
                        routes = list(
                            filter(lambda r: len(r[1].desc.asPath) == min_path, routes)
                        )
                        if len(routes) == 1:
                            return routes.pop()[0]
                        else:
                            # Best Origin (IGP > EGP > UNK)
                            if any(
                                map(lambda r: r[1].desc.origin is Origin.IGP, routes)
                            ):
                                best_origin = Origin.IGP
                            elif any(
                                map(lambda r: r[1].desc.origin is Origin.EGP, routes)
                            ):
                                best_origin = Origin.EGP
                            else:
                                best_origin = Origin.UNK
                            routes = list(
                                filter(
                                    lambda r: r[1].desc.origin is best_origin, routes
                                )
                            )
                            if len(routes) == 1:
                                return routes.pop()[0]
                            else:
                                # The neighbor with the lowest ip address
                                min_addr = min(map(lambda r: r[0].addr._addr, routes))
                                routes = list(
                                    filter(
                                        lambda r: r[0].addr._addr == min_addr, routes
                                    )
                                )
                                return routes.pop()[0]

    def to_dict(self):
        result = []
        for neighbor, table in self.tables.items():
            for dct in table.to_dict():
                dct["peer"] = neighbor.peer_addr.to_str()
                result.append(dct)
        return result


class ForwardingTable(Serializer):
    """Encapsulates a single neighbor's forwarding table, detailing which networks this hop leads to."""

    def __init__(self):
        """Creates a new, empty forwarding table."""
        self.networks = set()

    def update(self, network):
        """Appends the given network to this forwarding tables list of networks.
        This object will now recognize the provided network as "reachable".

        network Network: The new network that is reachable
        """
        self.networks.add(network)
        self._coalesce()

    def _coalesce(self):
        """Checks the table recursively, to ensure that all networks are as combined as the may be."""
        pass

    def revoke(self, network):
        """Removes the given network from this forwarding tables list of networks.
        This object will no longer recognize the provided network as "reachable".

        network Network: The network that is no longer reachable
        """
        pass

    def best_route(self, target):
        """Locates the route to reach the target. If no route leads to the target,
        then `None` is returned.

        target IpAddress: The target for which to find a route to

        returns: The Network object leading to the target, or `None` if no appropriate
        route could be located.
        """
        for net in self.networks:
            if net.leads_to(target):
                return net
        return None

    def to_dict(self):
        def net_to_dict(net):
            return {
                "network": net.prefix.to_str(),
                "netmask": net.mask.to_str(),
            }

        return map(net_to_dict, self.networks)


### Messages
### --------


class Message(Serializer):
    """Encapsulates some message sent over the network."""

    def __init__(self, src, dst, msg_type):
        """Creates a new message object

        src IpAddress: The source address of this message
        dst IpAddress: The destination address of this message
        msg_type MessageType: The type of message that this object represents
        """
        self.src = src
        self.dst = dst
        self.msg_type = msg_type

    def to_dict(self):
        return {
            "src": self.src.to_str(),
            "dst": self.dst.to_str(),
            "type": self.msg_type.value,
            "msg": {},
        }


class UpdateMsg(Message):
    """A message containing route announcement updates."""

    def __init__(self, src, dst, network):
        super().__init__(src, dst, MessageType.update)
        self.network = network

    def to_dict(self):
        dct = super().to_dict()
        dct["msg"] = self.network.to_dict()
        return dct


class RevokeMsg(Message):
    """A message revoking route announcements."""

    def __init__(self, src, dst, networks):
        super().__init__(src, dst, MessageType.revoke)
        self.networks = networks

    def to_dict(self):
        dct = super().to_dict()
        dct["msg"] = list(map(lambda n: n.to_dict(), self.networks))
        return dct


class DataMsg(Message):
    """A message containing some user-data, to be forwarded to its destination."""

    def __init__(self, src, dst, data):
        super().__init__(src, dst, MessageType.data)
        self.data = data

    def to_dict(self):
        dct = super().to_dict()
        dct["msg"] = self.data
        return dct


class NoRouteMsg(Message):
    """A message indicating that there is no available route to deliver some packet."""

    def __init__(self, src, dst):
        super().__init__(src, dst, MessageType.no_route)


class DumpMsg(Message):
    """A message requesting this router dump its current routing table state."""

    def __init__(self, src, dst):
        super().__init__(src, dst, MessageType.dump)


class TableMsg(Message):
    """A message containing information describing the internal routing table."""

    def __init__(self, src, dst, networks):
        super().__init__(src, dst, MessageType.table)
        self.networks = networks

    def to_dict(self):
        dct = super().to_dict()
        dct["msg"] = self.networks
        return dct


def parse_msg(msg):
    """Parses the provided message json into an object."""
    src = IpAddress(msg["src"])
    dst = IpAddress(msg["dst"])
    t = MessageType.from_str(msg["type"])
    data = msg["msg"]

    log(f"Message parsed; From {msg['src']} To {msg['dst']}, of Type {msg['type']}.")

    if t is MessageType.update:
        desc = NetworkDesc(
            data["localpref"], data["selfOrigin"], data["ASPath"], data["origin"]
        )
        net = Network(
            net_prefix=IpAddress(data["network"]),
            net_mask=IpAddress(data["netmask"]),
            net_desc=desc,
        )
        return UpdateMsg(src, dst, net)
    elif t is MessageType.revoke:
        routes = list(
            map(
                lambda r: Network(
                    net_prefix=IpAddress(r["network"]),
                    net_mask=IpAddress(r["netmask"]),
                    net_desc=None,
                ),
                data,
            )
        )
        return RevokeMsg(src, dst, routes)
    elif t is MessageType.data:
        return DataMsg(src, dst, data)
    elif t is MessageType.dump:
        return DumpMsg(src, dst)


### Main Logic
### ----------


def start():
    """Begins execution of the program."""
    asn, neighbors = ArgumentParser().parse()
    neighbors = [Neighbor(*n) for n in neighbors]
    router = Router(asn, neighbors)
    router.run()


if __name__ == "__main__":
    verbose = True
    start()
