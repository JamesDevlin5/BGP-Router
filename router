#!/usr/bin/env python3

# CLI-arg parsing
import argparse

# R/W socket data
import json

# Enumerate structure
from enum import Enum

# Sockets
from socket import socket, SOCK_SEQPACKET, AF_UNIX

# Async
import select

### Necessary Enum structures
### -------------------------


class Relationship(Enum):
    """The relationship between two BGP neighbors"""

    CUST = "cust"
    PROV = "prov"
    PEER = "peer"

    @classmethod
    def from_str(cls, string):
        """Converts the provided relationship string into its enum class form.

        string str: The string indicating some relationship between BGP nodes

        returns: The relationship object corresponding to the input argument
        """
        for rel in cls:
            if rel.value == string:
                return rel
        raise ValueError(f"Could not locate relationship type of neighbor: {string}")


class Origin(Enum):
    """A router location, internal or external of the local AS"""

    IGP = "IGP"
    EGP = "EGP"
    UNK = "UNK"

    @classmethod
    def from_str(cls, string):
        """Converts the provided origin string into its enum class form.

        string str: The string indicating the origin of some BGP node

        returns: The origin object corresponding to the input argument
        """
        for orig in cls:
            if orig.value == string:
                return orig
        return cls.UNK


class MessageType(Enum):
    """The various different forms a message may take"""

    update = "update"
    revoke = "revoke"
    data = "data"
    no_route = "no route"
    dump = "dump"
    table = "table"

    @classmethod
    def from_str(cls, string):
        """Converts the provided message type string into its enum class form.

        string str: The string indicating a message type

        returns: The message type object corresponding to the input argument
        """
        for category in cls:
            if category.value == string:
                return category
        return None


### Core Structures
### ---------------


class IpAddress:
    def __init__(self, string):
        """Creates an IpAddress object from a quad-dotted notation string

        string str: The input string, a quad-dotted notation ip address
        """
        ip_bytes = list(map(int, string.split(".")))
        assert (
            len(ip_bytes) == 4
        ), "Invalid IpAddress, only accepts quad-dotted notation"
        self._addr = self._bytes_to_int(ip_bytes)

    def _bytes_to_int(self, ip_bytes):
        """Converts a tuple of bytes into a single integer

        ip_bytes (int): A tuple consisting of four elements: the bytes representing an ip address

        returns: A single integer, equivalent to the input bytes
        """
        b1, b2, b3, b4 = map(lambda x: x & 0xFF, ip_bytes)
        return b1 << 24 | b2 << 16 | b3 << 8 | b4

    def _int_to_bytes(self, ip_int):
        """Converts an integer into a tuple of bytes

        ip_int int: The integer representing an ip address

        returns: A list of four bytes; each byte in the ip address
        """
        ip_bytes = []
        for i in range(4):
            shift = 0xFF << (i * 8)
            ip_byte = (ip_int & shift) >> (i * 8)
            ip_bytes.append(ip_byte)
        return ip_bytes[::-1]

    def to_bytes(self):
        """Converts this ip address to a list of bytes"""
        return self._int_to_bytes(self._addr)

    def to_str(self):
        """Converts this ip address to a dotted-decimal string"""
        return ".".join(map(str, self.to_bytes()))


class NetworkDesc:
    """Encapsulates the traits describing a network."""

    def __init__(self, localpref, selfOrigin, asPath, origin):
        """Constructs a network description object from the provided information.

        localpref str: The weight assigned to this network (higher is better)
        selfOrigin str: Whether this route was added by the local administrator or not
        asPath list(str): The list of autonomous systems traversed along this path (shorter is better)
        origin str: Location of the source of this route, within the local AS, external, or unknown
        """
        self.localpref = int(localpref)
        self.selfOrigin = bool(selfOrigin)
        self.asPath = list(asPath)
        self.origin = Origin.from_str(origin)

    def equal(self, other):
        """Checks whether this network description is identical (or equal) to the other network.

        other NetworkDesc: The other network description, to compare this one to

        returns: True if the provided network description is identical to this one, False otherwise
        """
        return all(
            self.localpref == other.localpref,
            self.selfOrigin == other.selfOrigin,
            self.asPath == other.asPath,
            self.origin == other.origin,
        )


class Network:
    """Encapsulates a network, with information about the route leading to this destination."""

    def __init__(self, net_prefix, net_mask, net_desc):
        """Constructs a network object with the provided information

        net_prefix IpAddress: The prefix describing this network
        net_mask IpAddress: The subnet mask describing this network
        net_desc NetworkDesc: The traits associated with this network
        """
        self.prefix = net_prefix
        self.mask = net_mask
        self.desc = net_desc


### Argument Parsing
### ----------------


class ArgumentParser:
    """An object to handle CLI arguments."""

    def __init__(self):
        """Creates a new internal parser object."""
        self.parser = self._create_parser()

    def _create_parser(self):
        """Sets up a new parser object and returns it."""

        def parse_neighbor(string):
            """A utility function to parse the neighbor input into an ip address and relationship identifier

            string str: A string of the form [ip address]-[relationship]

            returns: (The ip address), (The relationship); a tuple describing the neighbor
            """
            addr, rel = string.split("-")
            return IpAddress(addr), Relationship.from_str(rel)

        parser = argparse.ArgumentParser(
            description="A BGP router implementation in python."
        )
        parser.add_argument(
            "asn",
            type=int,
            help="The AS (autonomous system) number, which is uniquely assigned to identify this router",
        )
        parser.add_argument(
            "neighbor",
            nargs="+",
            type=parse_neighbor,
            help="The IP address and relationship of a neighboring router",
            metavar="<IP_Address>-<peer|prov|cust>",
        )
        return parser

    def parse(self):
        """Parses the arguments into information

        returns: (int, (IpAddress, Relationship)); a tuple consisting of:
                the autonomous system number uniquely identifying this node
                a list of addresses and their relationship to this node, representing all neighbors
        """
        args = self.parser.parse_args()
        return args.asn, args.neighbor


if __name__ == "__main__":
    print("Hello World!")
