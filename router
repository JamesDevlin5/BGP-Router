#!/usr/bin/env python3

# CLI-arg parsing
import argparse

# R/W socket data
import json

# Enumerate structure
from enum import Enum

# Sockets
from socket import socket, SOCK_SEQPACKET, AF_UNIX

# Async
import selectors

verbose = False


def log(msg):
    """Logs the provided message, if logging is enabled."""
    if verbose:
        print(msg)


### Necessary Enum structures
### -------------------------


class Relationship(Enum):
    """The relationship between two BGP neighbors"""

    CUST = "cust"
    PROV = "prov"
    PEER = "peer"

    @classmethod
    def from_str(cls, string):
        """Converts the provided relationship string into its enum class form.

        string str: The string indicating some relationship between BGP nodes

        returns: The relationship object corresponding to the input argument
        """
        for rel in cls:
            if rel.value == string:
                return rel
        raise ValueError(f"Could not locate relationship type of neighbor: {string}")


class Origin(Enum):
    """A router location, internal or external of the local AS"""

    IGP = "IGP"
    EGP = "EGP"
    UNK = "UNK"

    @classmethod
    def from_str(cls, string):
        """Converts the provided origin string into its enum class form.

        string str: The string indicating the origin of some BGP node

        returns: The origin object corresponding to the input argument
        """
        for orig in cls:
            if orig.value == string:
                return orig
        return cls.UNK


class MessageType(Enum):
    """The various different forms a message may take"""

    update = "update"
    revoke = "revoke"
    data = "data"
    no_route = "no route"
    dump = "dump"
    table = "table"

    @classmethod
    def from_str(cls, string):
        """Converts the provided message type string into its enum class form.

        string str: The string indicating a message type

        returns: The message type object corresponding to the input argument
        """
        for category in cls:
            if category.value == string:
                return category
        return None


### Core Structures
### ---------------


class IpAddress:
    def __init__(self, string):
        """Creates an IpAddress object from a quad-dotted notation string

        string str: The input string, a quad-dotted notation ip address
        """
        ip_bytes = list(map(int, string.split(".")))
        assert (
            len(ip_bytes) == 4
        ), "Invalid IpAddress, only accepts quad-dotted notation"
        self._addr = self._bytes_to_int(ip_bytes)

    def _bytes_to_int(self, ip_bytes):
        """Converts a tuple of bytes into a single integer

        ip_bytes (int): A tuple consisting of four elements: the bytes representing an ip address

        returns: A single integer, equivalent to the input bytes
        """
        b1, b2, b3, b4 = map(lambda x: x & 0xFF, ip_bytes)
        return b1 << 24 | b2 << 16 | b3 << 8 | b4

    def _int_to_bytes(self, ip_int):
        """Converts an integer into a tuple of bytes

        ip_int int: The integer representing an ip address

        returns: A list of four bytes; each byte in the ip address
        """
        ip_bytes = []
        for i in range(4):
            shift = 0xFF << (i * 8)
            ip_byte = (ip_int & shift) >> (i * 8)
            ip_bytes.append(ip_byte)
        return ip_bytes[::-1]

    def to_bytes(self):
        """Converts this ip address to a list of bytes"""
        return self._int_to_bytes(self._addr)

    def to_str(self):
        """Converts this ip address to a dotted-decimal string"""
        return ".".join(map(str, self.to_bytes()))


class Serializer:
    """An encapsulation of the ability to serialize an object to a dictionary."""

    def to_dict(self):
        """Converts this object to a dictionary representation."""
        return {}


class NetworkDesc(Serializer):
    """Encapsulates the traits describing a network."""

    def __init__(self, localpref, selfOrigin, asPath, origin):
        """Constructs a network description object from the provided information.

        localpref str: The weight assigned to this network (higher is better)
        selfOrigin str: Whether this route was added by the local administrator or not
        asPath list(str): The list of autonomous systems traversed along this path (shorter is better)
        origin str: Location of the source of this route, within the local AS, external, or unknown
        """
        self.localpref = int(localpref)
        self.selfOrigin = bool(selfOrigin)
        self.asPath = list(asPath)
        self.origin = Origin.from_str(origin)

    def equal(self, other):
        """Checks whether this network description is identical (or equal) to the other network.

        other NetworkDesc: The other network description, to compare this one to

        returns: True if the provided network description is identical to this one, False otherwise
        """
        return all(
            self.localpref == other.localpref,
            self.selfOrigin == other.selfOrigin,
            self.asPath == other.asPath,
            self.origin == other.origin,
        )

    def to_dict(self):
        return {
            "localpref": self.localpref,
            "selfOrigin": self.selfOrigin,
            "ASPath": self.asPath,
            "origin": self.origin.value,
        }


class Network(Serializer):
    """Encapsulates a network, with information about the route leading to this destination."""

    def __init__(self, net_prefix, net_mask, net_desc=None):
        """Constructs a network object with the provided information

        net_prefix IpAddress: The prefix describing this network
        net_mask IpAddress: The subnet mask describing this network
        net_desc NetworkDesc: The traits associated with this network
        """
        self.prefix = net_prefix
        self.mask = net_mask
        self.desc = net_desc

    def to_dict(self):
        if self.desc:
            dct = self.desc.to_dict()
        else:
            dct = {}
        dct["network"] = self.prefix.to_str()
        dct["netmask"] = self.mask.to_str()
        return dct


### Argument Parsing
### ----------------


class ArgumentParser:
    """An object to handle CLI arguments."""

    def __init__(self):
        """Creates a new internal parser object."""
        self.parser = self._create_parser()

    def _create_parser(self):
        """Sets up a new parser object and returns it."""

        def parse_neighbor(string):
            """A utility function to parse the neighbor input into an ip address and relationship identifier

            string str: A string of the form [ip address]-[relationship]

            returns: (The ip address), (The relationship); a tuple describing the neighbor
            """
            addr, rel = string.split("-")
            return IpAddress(addr), Relationship.from_str(rel)

        parser = argparse.ArgumentParser(
            description="A BGP router implementation in python."
        )
        parser.add_argument(
            "asn",
            type=int,
            help="The AS (autonomous system) number, which is uniquely assigned to identify this router",
        )
        parser.add_argument(
            "neighbor",
            nargs="+",
            type=parse_neighbor,
            help="The IP address and relationship of a neighboring router",
            metavar="<IP_Address>-<peer|prov|cust>",
        )
        return parser

    def parse(self):
        """Parses the arguments into information

        returns: (int, (IpAddress, Relationship)); a tuple consisting of:
                the autonomous system number uniquely identifying this node
                a list of addresses and their relationship to this node, representing all neighbors
        """
        args = self.parser.parse_args()
        return args.asn, args.neighbor


### Networking Core
### ---------------

# Number of bytes to read on each call to `recv` of a socket
BUFF_SIZE = 4096


class Neighbor:
    """Encapsulates the link between this node and some neighbor."""

    def __init__(self, addr, relation):
        """Constructs a new neighbor object, describing a neighboring BGP node

        addr IpAddress: The ip address of the neighboring node
        relation Relationship: The relationship between this neighbor and this node
        """
        addr = addr.to_str()
        self.relation = relation
        # The address of the neighboring router
        self.peer_addr = IpAddress(addr)
        # The address our router is using to communicate with this neighbor
        self.addr = IpAddress(addr[:-1] + "1")

        log(f"Created neighbor object ({relation.value}) @ {addr}.")

        # The socket communicating with this neighbor
        self.sock = socket(AF_UNIX, SOCK_SEQPACKET)
        self.sock.setblocking(False)
        self.sock.connect(addr)

        log(f"Neighbor {addr} successfully connected.")

    def recv_msg(self):
        """Receives a message from this neighbor.

        Will attempt to read from the buffer and then convert this data into a
        json continuously. The assumption is that the network will deliver the
        packets correctly, and we must continue attempting to receive the entire
        object before accepting the message.
        """
        m = b""
        while True:
            # Read socket
            m += self.sock.recv(BUFF_SIZE)
            try:
                # Attempt to deserialize
                result = json.loads(m)
            except json.JSONDecodeError:
                # Could not interpret json object, must not be done receiving it
                pass
            else:
                # Successfully loaded object
                return result

    def send_msg(self, msg):
        """Sends the provided message.

        msg str: The string message to send to this neighbor
        """
        self.sock.sendall(json.dumps(msg).encode("ascii"))

    def close(self):
        """Closes the socket, terminating the connection to this neighbor."""
        self.sock.close()


class Router:
    """Encapsulates a BGP router node, with a provided asn and neighboring routers."""

    def __init__(self, asn, neighbors):
        """Creates a new router object, to handle neighboring nodes and messages

        asn int: The unique identifier associated with this node
        neighbors [Neighbor]: A list of neighboring bgp router objects
        """
        self.asn = asn
        log(f"Created router object with id {asn}.")
        self.selector = selectors.EpollSelector()
        for n in neighbors:
            self._register_neighbor(n)

    def _register_neighbor(self, neighbor):
        """Registers this neighbor with the selector object

        neighbor Neighbor: The neighbor to register, indicating messages may be received from them
        """
        self.selector.register(neighbor.sock, selectors.EVENT_READ, neighbor)
        log(f"Registered neighbor {neighbor.addr.to_str()} on polling object.")

    def run(self):
        """Continuously loops, checking for new messages from neighbors and reacting to them."""
        log(f"Running...")
        while True:
            for key, _ in self.selector.select():
                sender = key.data


### Messages
### --------


class Message(Serializer):
    """Encapsulates some message sent over the network."""

    def __init__(self, src, dst, msg_type):
        """Creates a new message object

        src IpAddress: The source address of this message
        dst IpAddress: The destination address of this message
        msg_type MessageType: The type of message that this object represents
        """
        self.src = src
        self.dst = dst
        self.msg_type = msg_type

    def to_dict(self):
        return {
            "src": self.src.to_str(),
            "dst": self.dst.to_str(),
            "type": self.msg_type.value,
            "msg": {},
        }


class UpdateMsg(Message):
    """A message containing route announcement updates."""

    def __init__(self, src, dst, networks):
        super().__init__(src, dst, MessageType.update)
        self.networks = networks

    def to_dict(self):
        dct = super().to_dict()
        dct["msg"] = self.networks.to_dict()
        return dct


class RevokeMsg(Message):
    """A message revoking route announcements."""

    def __init__(self, src, dst, networks):
        super().__init__(src, dst, MessageType.revoke)
        self.networks = networks

    def to_dict(self):
        dct = super().to_dict()
        dct["msg"] = self.networks.to_dict()
        return dct


class DataMsg(Message):
    """A message containing some user-data, to be forwarded to its destination."""

    def __init__(self, src, dst, data):
        super().__init__(src, dst, MessageType.data)
        self.data = data

    def to_dict(self):
        dct = super().to_dict()
        dct["msg"] = self.data
        return dct


class NoRouteMsg(Message):
    """A message indicating that there is no available route to deliver some packet."""

    def __init__(self, src, dst):
        super().__init__(src, dst, MessageType.no_route)


class DumpMsg(Message):
    """A message requesting this router dump its current routing table state."""

    def __init__(self, src, dst):
        super().__init__(src, dst, MessageType.dump)


class TableMsg(Message):
    """A message containing information describing the internal routing table."""

    def __init__(self, src, dst):
        super().__init__(src, dst, MessageType.table)

    def register(self, net_prefix, net_mask, peer_addr):
        """Registers the network information and next-hop address provided

        net_prefix IpAddress: The network prefix describing the avaiable route
        net_mask IpAddress: The CIDR netmask associated with this network
        peer_addr IpAddress: The address of the next-hop router along this path
        """
        self.networks.append(
            {
                "network": net_prefix.to_str(),
                "netmask": net_mask.to_str(),
                "peer": peer_addr.to_str(),
            }
        )

    def to_dict(self):
        dct = super().to_dict()
        dct["msg"] = self.networks
        return dct


### Main Logic
### ----------


def start():
    """Begins execution of the program."""
    asn, neighbors = ArgumentParser().parse()
    neighbors = [Neighbor(*n) for n in neighbors]


if __name__ == "__main__":
    # verbose = True
    start()
